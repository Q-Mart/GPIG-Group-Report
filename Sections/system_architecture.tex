An overview of the system architecture, including the way in which the capabilities of new and emerging digital technologies have been leveraged, the types of data utilised and how the prototyped system supports the safe and secure routing of a diplomatic courier travelling from an initial location to a series of destinations in the world 

\section{Front-end} \label{frontendarch}
In order to allow the users to interact with our system, we have designed an interface for each user type. We can distinguish three different types of people that will need to access and alter the appropriate elements of our product. First, there are the couriers which must be given instructions to follow together with the recipient information. Next, we have the supervisors which are responsible for guiding the couriers and passing optimal routes to them. Finally we have the customers of our system that should be noticed about the progress of their delivery.

Each user will have their own login and password with which they can access their account on the appropriate application. To ensure that the data passed between the supervisors and couriers is secure, it will be sent through our own network described in the communication section. The information shared with the customer accounts will be very limited, therefore in the design we propose to use the ordinary internet connection available to everyone.

\subsection{Supervisors application} \label{supervisorsarch}
The most complex front end component is the application for the supervisors which will be used in the control room. It will be implemented as a dynamic web application. Once a supervisors log in to the system, they will be able to open the following views available through the navigation bar at the top of the page:
\begin{itemize}
    \item Map - this view will present a world map with current locations of all couriers and briefcases which are currently on a delivery mission. In case of emergency, the courier marker will flash red. This will be useful to quickly inspect progress of each courier and quickly understand the concept of possible threats if a courier is marked in red.
    \item Couriers - allows the supervisors to create new courier accounts in the database and edit the existing ones. They will be able to see the details of each courier including their current location and busy status. Another key feature of this view enables communication with each courier individually by sending/receiving direct text messages.
    \item Customers - simple view allowing for creation and edition of customer records. The supervisor will also be able to see any previous orders from each customer.
    \item Deliveries - allows for creation and edition of delivery missions. During the creation process, a supervisor will be able to select the sender and recipient from of the delivery, allocate multiple couriers to a mission and add any constraints to the route. Once all of those options have been selected, a route will be generated. The supervisor can then inspect the route and correct it by adding points to go through if necessary before adding the delivery to the database.
    \item Server logs - 
\end{itemize}
\subsection{Couriers application} \label{couriersarch}
\subsection{Customers application} \label{customersarch}



\section{Back-end} \label{backendarch}
\subsection{Customer database} \label{databasearch}
\begin{flushleft}
The first component of the backend is a database of customer and staff information. Its most important task is storing delivery information and constraints, which are merged with the maps database to provide directions to the courier. It is designed to store the following datatypes:
\end{flushleft}
\begin{minipage}{6.5cm}
    Customer: \{
    \begin{itemize} 
        \itemsep-0.5em
        \item[] customerId: id,
        \item[] name: string,
        \item[] address: string,
        \item[] postcode: string,
        \item[] city: string,
        \item[] country: string,
        \item[] publicKey: string,
        \item[] contactNumber: string,
        \item[] email: string,
        \item[] constraints: id
    \end{itemize}
    \}
\end{minipage}
\begin{minipage}{10cm}
    \hspace{1cm} \\
    \begin{itemize}
        \itemsep-0.5em
        \item[] \textit{unique customer identifier}
        \item[] \textit{customer name}
        \item[] \textit{address address}
        \item[] \textit{address postcode}
        \item[] \textit {address city}
        \item[] \textit{address country}
        \item[] \textit{customer public key, if known}
        \item[] \textit{customer phone number}
        \item[] \textit{customer email}
        \item[] \textit{identifier of customer constraint}
    \end{itemize}
    \hspace{1cm} \\
\end{minipage}
\begin{flushleft}
Every customer is a sender or receiver in a delivery: 
\end{flushleft}
\begin{minipage}{6.5cm}
    Delivery: \{
    \begin{itemize}
        \itemsep-0.5em
        \item[] deliveryId: id,
        \item[] sender: id,
        \item[] receiver: id,
        \item[] preferDestroy: boolean,
        \item[] customerMap: id,
        \item[] customerPublicKey: string,
        \item[] reinforcedBriefcase: boolean,
        \item[] lockMessage: string,
        \item[] couriers: [id],
        \item[] currentCourier: id,
        \item[]  supervisors: [id],
        \item[] constraints: id
    \end{itemize}
    \}
\end{minipage}
\begin{minipage}{10cm}
    \hspace{1cm} \\
    \begin{itemize}
        \itemsep-0.5em
        \item[] \textit{unique delivery identifier}
        \item[] \textit{sending customer id}
        \item[] \textit{receiving customer id}
        \item[] \textit{destroy package on capture preference}
        \item[] \textit{identifier of optional custom map}
        \item[] \textit{optional custom receiver public key}
        \item[] \textit{whether to use reinforced briefcase}
        \item[] \textit{reinforced briefcase password}
        \item[] \textit{identifiers of couriers handling the package}
        \item[] \textit{identifier of courier currently holding the package}
        \item[]  \textit{identifiers of supervisors handling the package}
        \item[] \textit{identifier of delivery constraint}
    \end{itemize}
    \hspace{1cm} \\
\end{minipage}
\begin{flushleft}
Every delivery links to a constraint object defining customer preferences.
\end{flushleft}
\begin{minipage}{7cm}
    Constraint: \{ 
    \begin{itemize}
        \itemsep-0.5em
        \item[] constraintId: id,
        \item[] active: boolean,
        \item[] bannedCountries: [string],
        \item[] bannedAirspaces: [string],
        \item[] bannedWaters: [string],
        \item[] bannedRoads: [string],
        \item[] allowedCar: boolean,
        \item[] allowedBoat: boolean,
        \item[] allowedFlight: boolean,
        \item[] allowedPublicTransport: boolean
        \item[] deadline: string
    \end{itemize}
    \}
\end{minipage}
\begin{minipage}{10cm}
    \hspace{1cm} \\
    \begin{itemize}
        \itemsep-0.5em
        \item[] \textit{unique identifier of constraint}
        \item[] \textit{whether constraint is in use}
        \item[] \textit{list of countries to avoid}
        \item[] \textit{list of airspaces to avoid}
        \item[] \textit{list of bodies of water to avoid}
        \item[] \textit{list of roads to avoid}
        \item[] \textit{(booleans specifying  which}
        \item[] \textit{methods of transport are allowed)}
        \item[] \hspace{1cm}
        \item[] \hspace{1cm}
        \item[] \textit{time by which delivery must occur (ISO format)}
    \end{itemize}
    \hspace{1cm} \\
\end{minipage}
\begin{flushleft}
Constraints exist on three levels: delivery, customer, and overall. Every delivery has its own constraints, allowing specific objects to be transported according to particular requirements. Every customer can have constraints applied to all of the deliveries where they are the sender. For example, government bodies may wish for none of their packages to cross countries they have strained diplomatic relations with. Finally, overall constraints are applied to all deliveries. These are applied when it becomes unsafe for anyone to traverse a particular area. Additional to these constraints we store staff contact and authentication data.
\end{flushleft}
\begin{minipage}{6.5cm}
    Courier: \{
    \begin{itemize}
        \itemsep-0.5em
        \item[] courierId: id,
        \item[] missionId: id,
        \item[] picture: string,
        \item[] name: string,
        \item[] publicKey: string,
        \item[] contactNumber: string,
        \item[] email: string,
        \item[] languages: [string],
        \item[] visas: [string],
        \item[] external: boolean,
        \item[] company: string
    \end{itemize}
    \}
\end{minipage}
\begin{minipage}{10cm}
    \hspace{1cm}
    \begin{itemize}
        \itemsep-0.5em
        \item[] \textit{unique identifier of courier}
        \item[] \textit{identifier of current delivery, if any}
        \item[] \textit{link to picture of courier}
        \item[] \textit{courier name}
        \item[] \textit{courier public key, for authentication}
        \item[] \textit{courier phone number}
        \item[] \textit{courier email}
        \item[] \textit{languages spoken by courier}
        \item[] \textit{visas courier possesses}
        \item[] \textit{whether the courier works for a different company}
        \item[] \textit{courier's company, if external}
    \end{itemize}
    \hspace{1cm}
\end{minipage}
\begin{flushleft}
The external and company attributes allow us to collaborate with other companies by outsourcing couriers.
\end{flushleft}
\begin{minipage}{6.5cm}
Supervisor: \{
\begin{itemize}
    \itemsep-0.5em
    \item[] supervisorId: id,
    \item[] name: string,
    \item[] contactNumber: string,
    \item[] email: string
\end{itemize}
\}
\end{minipage}
\begin{minipage}{10cm}
\hspace{1cm}
\begin{itemize}
    \itemsep-0.5em
    \item[] \textit{unique identifier of supervisor}
    \item[] \textit{supervisor's name}
    \item[] \textit{supervisor's phone number}
    \item[] \textit{supervisor's email address}
\end{itemize}
\hspace{1cm}
\end{minipage}
\begin{flushleft}
The database also stores all messages sent between staff on the private network.
\end{flushleft}
\begin{minipage}{6.5cm}
Message: \{
\begin{itemize}
    \itemsep-0.5em
    \item[] timestamp: string,
    \item[] message: string,
    \item[] fromType: string,
    \item[] fromId: string,
    \item[] toType: string,
    \item[] toId: string
\end{itemize}
\}
\end{minipage}
\begin{minipage}{10cm}
\hspace{1cm}
\begin{itemize}
    \itemsep-0.5em
    \item[] \textit{time the message was sent (ISO format)}
    \item[] \textit{message text}
    \item[] \textit{sender type (courier/supervisor)}
    \item[] \textit{sender's identifier}
    \item[] \textit{receiver type (courier/supervisor)}
    \item[] \textit{receiver's identifier}
\end{itemize}
\hspace{1cm}
\end{minipage}
\begin{flushleft}
Finally, the database stores an audit trail for every delivery, using objects called delivery events.
\end{flushleft}
\begin{minipage}{6.5cm}
DeliveryEvent: \{
\begin{itemize}
    \itemsep-0.5em
    \item[] deliveryId: id,
    \item[] timestamp: string,
    \item[] latitude: float,
    \item[] longitude: float,
    \item[] description: string,
    \item[] notes: string
\end{itemize}
\}
\end{minipage}
\begin{minipage}{10cm}
\hspace{1cm}
\begin{itemize}
    \itemsep-0.5em
    \item[] \textit{identifier of delivery}
    \item[] \textit{time at which event occurred (ISO format)}
    \item[] \textit{latitude at which event occurred}
    \item[] \textit{longitude at which event occurred}
    \item[] \textit{description of event (e.g. "delivered")}
    \item[] \textit{optional additional notes}
\end{itemize}
\hspace{1cm}
\end{minipage}
\begin{figure}[h]
\includegraphics[scale=0.5]{database_outline.png}
    \centering
    \caption{Outline of Redis database}
    \label{fig:redis_database}
\end{figure}
\begin{flushleft}
This information will be stored in a Redis database within a Docker image, for ease of setup and added security. Redis was chosen for its efficiency and security-- it is a simple database designed with speed in mind, and has measures in place to avoid third party attacks\cite{redisSecutiry}. It allows us to rename and disable commands such that potential attackers cannot send commands to the database. We will use this to ban clearing the database contents, and obscure all commands used by the API code. Redis has no concept of string escaping, making injection attacks impossible. It does not support encryption, but to compensate for this we will use a firewall to block all but the API server from communicating with it, and encrypt all API responses.
\end{flushleft}
\begin{flushleft}
A set of Python functions will be defined to verify and process data sent to Redis such that it contains the attributes and data types described. These functions are to be used by a class called RedisInterface. This is a wrapper around the Redis Python package, implementing functions for adding and retrieving all of the above objects.
\end{flushleft}
\begin{flushleft}
An API layer will be written on top of this using Flask, allowing the frontend to access, update, and delete data without needing knowledge of which RedisInterface methods to call. This API will also be enclosed in a Docker image, allowing us full control of the API server. The architecture of the Redis API is summarised in the following figure.
\end{flushleft}
\begin{figure}[h]
    \centering
    \includegraphics[scale=0.5]{redis_backend_diagram.png}
    \caption{Redis API software architecture}
    \label{fig:redis_architecturel}
\end{figure}
\begin{flushleft}
The API is designed with the database structure in mind, providing simple links to constraints on all levels, lists of staff and customers, as well as specific information retrievable by ID. The following table provides a list of URLs, callable methods, and expected API responses.
\end{flushleft}
\begin{center}
\begin{tabular}{ | m{6.1cm} | m{3.8cm}| m{6cm} | } 
\hline
URL & Methods & Description \\
\hline
/constraints/overall & GET, POST, DELETE & Get, modify, or remove overall constraints \\
\hline
/constraints/customer/<customerId> & GET, POST, DELETE & Get, modify, or remove a specific customer's constraints \\
\hline
/constraints/delivery/<deliveryId> & GET, POST, DELETE & Get, modify, or remove a specific delivery's constraints\\
\hline
/customers & GET, POST & Get the full list of customers, or add a customer\\
\hline
/customers/<customerId> & GET, PUT, DELETE & Get, update, or remove a customer's data\\
\hline
/couriers & GET, POST & Get the full list of couriers, or add a courier\\
\hline
/couriers/<courierId> & GET, PUT, DELETE & Get, update, or remove a courier's data\\
\hline
/supervisors & GET, POST & Get the full list of supervisors, or add a supervisor\\
\hline
/supervisors/<supervisorId> & GET, PUT, DELETE & Get, update, or remove a supervisor's data\\
\hline
/deliveries & GET, POST & Get the full list of deliveries, or add a delivery\\
\hline
/deliveries/<deliveryId> & GET, PUT, DELETE & Get, update, or remove a delivery\\
\hline
/deliveries/customer/<customerId> & GET & Get all deliveries where a particular customer is either sender or receiver\\
\hline
/events/<deliveryId> & GET & Get all of a delivery's events\\
\hline
/messages & GET, POST & Get all messages sent or received by a specific person, or add a message\\
\hline
\end{tabular}
\end{center}

\subsection{Maps API} \label{mapsarch}

The second major component of the backend part of the system is the mapping and routing API which is used by the couriers to get step by step directions and by supervisors to view and confirm the routes that couriers will take.

For the prototype system Google Maps has been used for all of the mapping data however we would like to offer customers the option of using other mapping services or even their own maps in the product when it is brought to market. This could allow some customers to provide more detailed maps of certain areas for example. The API provides a route along with the step by step direction for how to reach the destination, this route can then easily be plotted on a map and the directions can easily be displayed by the frontend of the system that the couriers and supervisors interact with.

Currently direction and routes allow for two modes of transport, driving and flying. We may wish to add to this in future to allow for other modes of transport to be used for example trains or walking. The customer could have the option to select their preferred modes of transport. The constraints on the routes are currently implemented as a list of way points that can be added by supervisors to ensure that certain areas are avoided however in the finished product this would be automated.

As with the database API this is a RESTful API that provides responses in JSON and runs as part of a flask app. The whole API (both the database API and the routing API) are part of the same flask app that can easily be called by the frontend part of the system that will be used by both the couriers and supervisors.

\section{Communication} \label{communicationarch}

\section{Private Satellite Network}

\section{Briefcase} \label{briefcasearch}
The design of the briefcase must be considered from both a hardware and software perspective. The general design of the hardware system is shown in Fig. \ref{fig:briefcase_architecture}. All peripherals in the system are represented as circles in Fig. \ref{fig:briefcase_architecture}, while intermediate components are represented as rectangles.
\begin{figure}[h]
    \centering
    \includegraphics[scale=0.4]{briefcase_architecture_diagram.png}
    \caption{Briefcase Hardware Architecture}
    \label{fig:briefcase_architecture}
\end{figure}

As it is common for microcontrollers to not have USB hosting capabilities, USB hosting hardware is required to read the contents of a memory stick that is plugged into the concealed USB port. This hardware could be similar to the hardware found on the Arduino USB Host Shield \cite{arduinoUSBHost}, or a microcontroller with USB On-The-Go (OTG) capabilities \cite{techopediaUSBOTG} such as the NXP MCF52211 ColdFire \cite{nxpDatasheet}. As well as this, the concealed USB port must be connected to the chosen microcontroller in order to program the briefcase with the set encrypted message.

The microcontroller is connected to an electronic lock (such as a solenoid \cite{solenoidDigikey} or a motorised lock \cite{motorisedLock}). Of course, microcontrollers are usually unable to drive such devices, so some form of driver hardware (such as a relay or a transistor) is anticipated. Furthermore, in the case of a customer deciding that they would like the contents of the briefcase destroyed in an unfortunate incident, a concealed panic button is connected to the microcontroller, which is also connected to some form of contents destruction mechanism via an appropriate driver. The contents destruction mechanism has not yet been formally decided and further research and development will be required to find a safe and effective method. Potentials methods include driving a large current through a thin wire to set the contents of the briefcase alight, using hydraulics to spray ink onto the contents or installing a paper shredding mechanism within the briefcase. Each of these ideas have their own unique disadvantages, such as whether they make the briefcase safe for air travel or are too heavy to implement.

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.4]{briefcase_state_machine.png}
    \caption{Briefcase State Machine}
    \label{fig:briefcase_state_machine}
\end{figure}
The software architecture of the briefcase itself is comparably simpler to its hardware and its behaviour can be described in the state machine in Fig. \ref{fig:briefcase_state_machine}. There are three states: \textit{Lock}, in which the briefcase is locked and the system is actively waiting for a USB memory stick to be inserted. If a USB memory stick is inserted, and contains the correct encrypted message, then the state machine moves to \textit{Unlock}, in which the briefcase is obviously unlocked. The system can only then move back to the \textit{Lock} state if the briefcase is closed and the USB stick containing the encrypted message is removed. In both of these states, if this option is chosen by the customer, a transition to the \textit{Destroy} state can be made by pressing the concealed panic button. In this state, the mechanism which destroys the  contents of the briefcase is activated. It is impossible to transition out of this state. Instead, it is intended that the platform will have to be manually be reprogrammed by one of our engineers. 